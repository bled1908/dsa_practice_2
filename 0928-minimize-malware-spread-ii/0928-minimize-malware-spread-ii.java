class Solution {
    int[] parents;
    int[] size;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int numOfNodes = graph.length;
        parents = new int[numOfNodes];
        size = new int[numOfNodes];

        boolean[] infectedNodes = new boolean[numOfNodes];

        // Set indices where nodes are infected
        for(int infectedNode:initial){
            infectedNodes[infectedNode]=true;
        }

        // Set parent of each non-infected node to self, i.e parent of 1 = 1 (if 1 is not infected)
        // Set size of each parent tree as 1.
        // Infected nodes size can be 0
        for (int currentNode = 0; currentNode < numOfNodes; currentNode++) {
            parents[currentNode] = currentNode;
            size[currentNode] = infectedNodes[currentNode] ? 0 : 1;
        }

        // Only union uninfected nodes
        for(int currentNode = 0; currentNode<numOfNodes; currentNode++){
            //if node is not infected, find its connected nodes
            if(!infectedNodes[currentNode]){
                for(int connectedNode = currentNode+1; connectedNode<numOfNodes; connectedNode++){
                    // if connectedNode is not infected and connected to currentNode, then union them
                    if(!infectedNodes[connectedNode] && graph[currentNode][connectedNode]==1){
                        // parents[] will be initialized
                        union(currentNode, connectedNode);
                    }
                }
            }
        }

        // Parents infected by infectedNodes
        Map<Integer, Set<Integer>> infectedToParents = new HashMap();

        // Infected Parents have how many nodes
        Map<Integer, Integer> infectedParentsToSize = new HashMap();

        for(int infectedNode: initial){
            Set<Integer> parentsInfected = infectedToParents.getOrDefault(infectedNode, new HashSet());

            for(int currentNode = 0; currentNode < numOfNodes; currentNode++){
                //If current node is not infected but is connected to an infectedNode, find the parents of current node
                // this will tell us which parents the infected node can infect
                if(!infectedNodes[currentNode] && graph[infectedNode][currentNode]==1){
                    int parentOfCurrentNode = findParent(currentNode);
                    parentsInfected.add(parentOfCurrentNode);
                    infectedToParents.put(infectedNode, parentsInfected);
                }
            }

            // Find how many nodes infected parent has
            for(int infectedParent : parentsInfected){
                infectedParentsToSize.put(infectedParent, infectedParentsToSize.getOrDefault(infectedParent, 0) +1);
            }
        }

        int maxSaved = 0;
        int resultNode = initial[0];

        for(int infectedNode:initial){
            int saved = 0;
            Set<Integer> infectedParents = infectedToParents.getOrDefault(infectedNode, new HashSet());

            for(int infectedParent : infectedParents){
                if(infectedParentsToSize.getOrDefault(infectedParent, 0)==1){
                    saved += size[infectedParent];
                }
            }

            if(saved > maxSaved || saved == maxSaved && infectedNode < resultNode){
                maxSaved = saved;
                resultNode = infectedNode;
            }
        }

        return resultNode;
    }

    public int findParent(int node){
        if(parents[node]!=node){
            return findParent(parents[node]);
        }
        return parents[node];
    }

    public void union(int node1, int node2){
        int parentOfNode1 = findParent(node1);
        int parentOfNode2 = findParent(node2);

        if(parentOfNode1==parentOfNode2){
            //already merged
            return;
        }

        if(size[parentOfNode1] < size[parentOfNode2]){
            parents[parentOfNode1] = parentOfNode2;
            size[parentOfNode2] = size[parentOfNode1] + size[parentOfNode2];
        } else {
            parents[parentOfNode2] = parentOfNode1;
            size[parentOfNode1] = size[parentOfNode1] + size[parentOfNode2];
        }
    }
}